{
  "version": 3,
  "sources": ["../src/updateSearchString.ts"],
  "sourcesContent": ["import {\n  DecodedValueMap,\n  encodeQueryParams,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport { extendParamConfigForKeys } from './inheritedParams';\nimport { getLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { QueryParamOptionsWithRequired } from './options';\nimport { removeDefaults } from './removeDefaults';\nimport { PartialLocation, QueryParamAdapter, UrlUpdateType } from './types';\nimport { applyUrlNames } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\n/**\n * Given a ?foo=1&bar=2 and { bar: 3, baz: true } produce ?foo=1&bar=3&baz=1\n * or similar, depending on updateType. The result will be prefixed with \"?\"\n * or just be the empty string.\n */\nexport function getUpdatedSearchString({\n  changes,\n  updateType,\n  currentSearchString,\n  paramConfigMap: baseParamConfigMap,\n  options,\n}: {\n  changes: ChangesType<DecodedValueMap<any>>;\n  updateType?: UrlUpdateType;\n  currentSearchString: string;\n  paramConfigMap: QueryParamConfigMap;\n  options: QueryParamOptionsWithRequired;\n}): string {\n  const { searchStringToObject, objectToSearchString } = options;\n  if (updateType == null) updateType = options.updateType;\n\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(\n    searchStringToObject,\n    currentSearchString\n  );\n\n  // see if we have unconfigured params in the changes that we can\n  // inherit to expand our config map instead of just using strings\n  const paramConfigMap = extendParamConfigForKeys(\n    baseParamConfigMap,\n    Object.keys(changes),\n    options.params\n  );\n\n  // update changes prior to encoding to handle removing defaults\n  // getting latest values when functional update\n  let changesToUse: Partial<DecodedValueMap<any>>;\n\n  // functional updates here get the latest values\n  if (typeof changes === 'function') {\n    const latestValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n\n    changesToUse = (changes as Function)(latestValues);\n  } else {\n    // simple update here\n    changesToUse = changes;\n  }\n\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n\n  // remove defaults\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n\n  // interpret urlNames\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n\n  let newSearchString: string;\n  if (updateType === 'push' || updateType === 'replace') {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges,\n    });\n  }\n\n  if (newSearchString?.length && newSearchString[0] !== '?') {\n    (newSearchString as any) = `?${newSearchString}`;\n  }\n\n  return newSearchString ?? '';\n}\n\n/**\n * uses an adapter to update a location object and optionally\n * navigate based on the updateType\n */\nexport function updateSearchString({\n  searchString,\n  adapter,\n  navigate,\n  updateType,\n}: {\n  searchString: string;\n  adapter: QueryParamAdapter;\n  navigate: boolean;\n  updateType?: UrlUpdateType;\n}) {\n  const currentLocation = adapter.location;\n\n  // update the location and URL\n  const newLocation: PartialLocation = {\n    ...currentLocation,\n    search: searchString,\n  };\n\n  if (navigate) {\n    // be defensive about checking updateType since it is somewhat easy to\n    // accidentally pass a second argument to the setter.\n    if (typeof updateType === 'string' && updateType.startsWith('replace')) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\n\ntype UpdateArgs = Parameters<typeof getUpdatedSearchString>[0] & {\n  adapter: QueryParamAdapter;\n};\n\nconst immediateTask = (task: Function) => task();\nconst timeoutTask = (task: Function) => setTimeout(() => task(), 0);\n// alternative could be native `queueMicrotask`\n\nconst updateQueue: UpdateArgs[] = [];\n\n/**\n * support batching by enqueuing updates (if immediate is not true)\n */\nexport function enqueueUpdate(\n  args: UpdateArgs,\n  { immediate }: { immediate?: boolean } = {}\n) {\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n\n      let searchString: string | undefined;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate: UpdateArgs =\n          i === 0\n            ? updates[i]\n            : { ...updates[i], currentSearchString: searchString! };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n\n      // do not update unnecessarily #234\n      if (\n        args.options.skipUpdateWhenNoChange &&\n        searchString === initialSearchString\n      ) {\n        return;\n      }\n\n      updateSearchString({\n        searchString: searchString ?? '',\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType,\n      });\n    });\n  }\n}\n"],
  "mappings": "AAAA;AAAA,EAEE;AAAA,OAEK;AACP,SAAS,yBAAyB;AAClC,SAAS,gCAAgC;AACzC,SAAS,8BAA8B;AACvC,SAAS,gCAAgC;AAEzC,SAAS,sBAAsB;AAE/B,SAAS,qBAAqB;AAYvB,SAAS,uBAAuB;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA,gBAAgB;AAAA,EAChB;AACF,GAMW;AACT,QAAM,EAAE,sBAAsB,qBAAqB,IAAI;AACvD,MAAI,cAAc;AAAM,iBAAa,QAAQ;AAE7C,MAAI;AACJ,QAAM,eAAe;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AAIA,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA,OAAO,KAAK,OAAO;AAAA,IACnB,QAAQ;AAAA,EACV;AAIA,MAAI;AAGJ,MAAI,OAAO,YAAY,YAAY;AACjC,UAAM,eAAe;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,mBAAgB,QAAqB,YAAY;AAAA,EACnD,OAAO;AAEL,mBAAe;AAAA,EACjB;AAEA,mBAAiB,kBAAkB,gBAAgB,YAAY;AAG/D,MAAI,QAAQ,uBAAuB;AACjC,mBAAe,gBAAgB,cAAc;AAAA,EAC/C;AAGA,mBAAiB,cAAc,gBAAgB,cAAc;AAE7D,MAAI;AACJ,MAAI,eAAe,UAAU,eAAe,WAAW;AACrD,sBAAkB,qBAAqB,cAAc;AAAA,EACvD,OAAO;AACL,sBAAkB,qBAAqB;AAAA,MACrC,GAAG;AAAA,MACH,GAAG;AAAA,IACL,CAAC;AAAA,EACH;AAEA,OAAI,mDAAiB,WAAU,gBAAgB,OAAO,KAAK;AACzD,IAAC,kBAA0B,IAAI;AAAA,EACjC;AAEA,SAAO,4CAAmB;AAC5B;AAMO,SAAS,mBAAmB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,QAAM,kBAAkB,QAAQ;AAGhC,QAAM,cAA+B;AAAA,IACnC,GAAG;AAAA,IACH,QAAQ;AAAA,EACV;AAEA,MAAI,UAAU;AAGZ,QAAI,OAAO,eAAe,YAAY,WAAW,WAAW,SAAS,GAAG;AACtE,cAAQ,QAAQ,WAAW;AAAA,IAC7B,OAAO;AACL,cAAQ,KAAK,WAAW;AAAA,IAC1B;AAAA,EACF;AACF;AAMA,MAAM,gBAAgB,CAAC,SAAmB,KAAK;AAC/C,MAAM,cAAc,CAAC,SAAmB,WAAW,MAAM,KAAK,GAAG,CAAC;AAGlE,MAAM,cAA4B,CAAC;AAK5B,SAAS,cACd,MACA,EAAE,UAAU,IAA6B,CAAC,GAC1C;AACA,cAAY,KAAK,IAAI;AACrB,MAAI,eAAe,YAAY,gBAAgB;AAE/C,MAAI,YAAY,WAAW,GAAG;AAC5B,iBAAa,MAAM;AACjB,YAAM,UAAU,YAAY,MAAM;AAClC,kBAAY,SAAS;AACrB,YAAM,sBAAsB,QAAQ,GAAG;AAEvC,UAAI;AACJ,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACvC,cAAM,iBACJ,MAAM,IACF,QAAQ,KACR,EAAE,GAAG,QAAQ,IAAI,qBAAqB,aAAc;AAC1D,uBAAe,uBAAuB,cAAc;AAAA,MACtD;AAGA,UACE,KAAK,QAAQ,0BACb,iBAAiB,qBACjB;AACA;AAAA,MACF;AAEA,yBAAmB;AAAA,QACjB,cAAc,sCAAgB;AAAA,QAC9B,SAAS,QAAQ,QAAQ,SAAS,GAAG;AAAA,QACrC,UAAU;AAAA,QACV,YAAY,QAAQ,QAAQ,SAAS,GAAG;AAAA,MAC1C,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;",
  "names": []
}
