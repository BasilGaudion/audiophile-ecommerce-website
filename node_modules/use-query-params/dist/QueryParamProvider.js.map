{
  "version": 3,
  "sources": ["../src/QueryParamProvider.tsx"],
  "sourcesContent": ["import * as React from 'react';\nimport {\n  mergeOptions,\n  defaultOptions,\n  QueryParamOptions,\n  QueryParamOptionsWithRequired,\n} from './options';\nimport { QueryParamAdapter, QueryParamAdapterComponent } from './types';\n\n/**\n * Shape of the QueryParamContext, which the hooks consume to read and\n * update the URL state.\n */\ntype QueryParamContextValue = {\n  adapter: QueryParamAdapter;\n  options: QueryParamOptionsWithRequired;\n};\n\nconst providerlessContextValue: QueryParamContextValue = {\n  adapter: {} as QueryParamAdapter,\n  options: defaultOptions,\n};\n\nexport const QueryParamContext = React.createContext<QueryParamContextValue>(\n  providerlessContextValue\n);\n\nexport function useQueryParamContext() {\n  const value = React.useContext(QueryParamContext);\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    (value === undefined || value === providerlessContextValue)\n  ) {\n    throw new Error('useQueryParams must be used within a QueryParamProvider');\n  }\n\n  return value;\n}\n\n/**\n * Props for the Provider component, used to hook the active routing\n * system into our controls. Note only the root provider requires\n * `adapter`. We try to encourage that via intellisense by writing\n * the types this way (you must provide at least one of adapter or options,\n * default intellisense suggests adapter required.)\n */\ntype QueryParamProviderProps = {\n  /** Main app goes here */\n  children: React.ReactNode;\n} & (\n  | {\n      adapter?: never;\n      options: QueryParamOptions;\n    }\n  | {\n      /** required for the root provider but not for nested ones */\n      adapter: QueryParamAdapterComponent;\n      options?: QueryParamOptions;\n    }\n);\n\nfunction QueryParamProviderInner({\n  children,\n  adapter,\n  options,\n}: {\n  children: React.ReactNode;\n  adapter?: QueryParamAdapter | undefined;\n  options?: QueryParamOptions;\n}) {\n  // allow merging in parent options\n  const { adapter: parentAdapter, options: parentOptions } =\n    React.useContext(QueryParamContext);\n\n  const value = React.useMemo(() => {\n    return {\n      adapter: adapter ?? parentAdapter,\n      options: mergeOptions(\n        parentOptions,\n        options\n      ) as QueryParamOptionsWithRequired,\n    };\n  }, [adapter, options, parentAdapter, parentOptions]);\n\n  return (\n    <QueryParamContext.Provider value={value}>\n      {children}\n    </QueryParamContext.Provider>\n  );\n}\n\n/**\n * Context provider for query params to have access to the\n * active routing system, enabling updates to the URL.\n */\nexport function QueryParamProvider({\n  children,\n  adapter,\n  options,\n}: QueryParamProviderProps) {\n  const Adapter = adapter;\n  return Adapter ? (\n    <Adapter>\n      {(adapter) => (\n        <QueryParamProviderInner adapter={adapter} options={options}>\n          {children}\n        </QueryParamProviderInner>\n      )}\n    </Adapter>\n  ) : (\n    <QueryParamProviderInner options={options}>\n      {children}\n    </QueryParamProviderInner>\n  );\n}\n\nexport default QueryParamProvider;\n"],
  "mappings": "AAAA,YAAY,WAAW;AACvB;AAAA,EACE;AAAA,EACA;AAAA,OAGK;AAYP,MAAM,2BAAmD;AAAA,EACvD,SAAS,CAAC;AAAA,EACV,SAAS;AACX;AAEO,MAAM,oBAAoB,MAAM;AAAA,EACrC;AACF;AAEO,SAAS,uBAAuB;AACrC,QAAM,QAAQ,MAAM,WAAW,iBAAiB;AAChD,MAEG,UAAU,UAAa,UAAU,0BAClC;AACA,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC3E;AAEA,SAAO;AACT;AAwBA,SAAS,wBAAwB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AACF,GAIG;AAED,QAAM,EAAE,SAAS,eAAe,SAAS,cAAc,IACrD,MAAM,WAAW,iBAAiB;AAEpC,QAAM,QAAQ,MAAM,QAAQ,MAAM;AAChC,WAAO;AAAA,MACL,SAAS,4BAAW;AAAA,MACpB,SAAS;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,GAAG,CAAC,SAAS,SAAS,eAAe,aAAa,CAAC;AAEnD,SACE,oCAAC,kBAAkB,UAAlB;AAAA,IAA2B;AAAA,KACzB,QACH;AAEJ;AAMO,SAAS,mBAAmB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF,GAA4B;AAC1B,QAAM,UAAU;AAChB,SAAO,UACL,oCAAC,eACE,CAACA,aACA,oCAAC;AAAA,IAAwB,SAASA;AAAA,IAAS;AAAA,KACxC,QACH,CAEJ,IAEA,oCAAC;AAAA,IAAwB;AAAA,KACtB,QACH;AAEJ;AAEA,IAAO,6BAAQ;",
  "names": ["adapter"]
}
