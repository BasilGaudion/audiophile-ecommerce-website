{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/useQueryParam.ts", "../../src/useQueryParams.ts", "../../src/decodedParamCache.ts", "../../src/inheritedParams.ts", "../../src/shallowEqual.ts", "../../src/latestValues.ts", "../../src/urlName.ts", "../../src/memoSearchStringToObject.ts", "../../src/options.ts", "../../src/QueryParamProvider.tsx", "../../src/updateSearchString.ts", "../../src/removeDefaults.ts", "../../src/withQueryParams.tsx", "../../src/QueryParams.tsx"],
  "sourcesContent": ["export * from 'serialize-query-params';\nexport * from './types';\n\nexport { useQueryParam } from './useQueryParam';\nexport { useQueryParams } from './useQueryParams';\nexport { withQueryParams, withQueryParamsMapped } from './withQueryParams';\nexport type { InjectedQueryProps } from './withQueryParams';\n\nexport { QueryParams } from './QueryParams';\nexport type { QueryParamsProps, QueryRenderProps } from './QueryParams';\nexport { QueryParamProvider } from './QueryParamProvider';\nexport type {\n  QueryParamOptions,\n  QueryParamOptionsWithRequired,\n} from './options';\n", "import { useCallback, useMemo } from 'react';\nimport { QueryParamConfig } from 'serialize-query-params';\nimport { QueryParamOptions } from './options';\nimport { UrlUpdateType } from './types';\nimport useQueryParams from './useQueryParams';\n\ntype NewValueType<D> = D | ((latestValue: D) => D);\n\n/**\n * Given a query param name and query parameter configuration ({ encode, decode })\n * return the decoded value and a setter for updating it.\n *\n * The setter takes two arguments (newValue, updateType) where updateType\n * is one of 'replace' | 'replaceIn' | 'push' | 'pushIn', defaulting to\n * 'pushIn'.\n */\nexport const useQueryParam = <TypeToEncode, TypeFromDecode = TypeToEncode>(\n  name: string,\n  paramConfig?: QueryParamConfig<TypeToEncode, TypeFromDecode>,\n  options?: QueryParamOptions\n): [\n  TypeFromDecode,\n  (newValue: NewValueType<TypeToEncode>, updateType?: UrlUpdateType) => void\n] => {\n  const paramConfigMap = useMemo(\n    () => ({ [name]: paramConfig ?? 'inherit' }),\n    [name, paramConfig]\n  );\n  const [query, setQuery] = useQueryParams(paramConfigMap, options);\n  const decodedValue = query[name];\n  const setValue = useCallback(\n    (newValue: NewValueType<TypeToEncode>, updateType?: UrlUpdateType) => {\n      if (typeof newValue === 'function') {\n        return setQuery((latestValues) => {\n          const newValueFromLatest = (newValue as Function)(latestValues[name]);\n          return { [name]: newValueFromLatest };\n        }, updateType);\n      }\n      return setQuery({ [name]: newValue } as any, updateType);\n    },\n    [name, setQuery]\n  );\n\n  return [decodedValue, setValue];\n};\n", "import { useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  DecodedValueMap,\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport {\n  extendParamConfigForKeys,\n  convertInheritedParamStringsToParams,\n} from './inheritedParams';\nimport { makeStableGetLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { mergeOptions, QueryParamOptions } from './options';\nimport { useQueryParamContext } from './QueryParamProvider';\nimport {\n  QueryParamConfigMapWithInherit,\n  SetQuery,\n  UrlUpdateType,\n} from './types';\nimport { enqueueUpdate } from './updateSearchString';\nimport { serializeUrlNameMap } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\ntype UseQueryParamsResult<QPCMap extends QueryParamConfigMap> = [\n  DecodedValueMap<QPCMap>,\n  SetQuery<QPCMap>\n];\ntype ExpandInherits<QPCMap extends QueryParamConfigMapWithInherit> = {\n  [ParamName in keyof QPCMap]: QPCMap[ParamName] extends string\n    ? typeof StringParam\n    : QPCMap[ParamName] extends QueryParamConfig<any>\n    ? QPCMap[ParamName]\n    : never;\n};\n\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMap = QueryParamConfigMap\n>(): UseQueryParamsResult<QPCMap>;\nexport function useQueryParams<QPCMap extends QueryParamConfigMapWithInherit>(\n  names: string[],\n  options?: QueryParamOptions\n): UseQueryParamsResult<ExpandInherits<QPCMap>>;\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMapWithInherit,\n  OutputQPCMap extends QueryParamConfigMap = ExpandInherits<QPCMap>\n>(\n  paramConfigMap: QPCMap,\n  options?: QueryParamOptions\n): UseQueryParamsResult<OutputQPCMap>;\nexport function useQueryParams(\n  arg1?: string[] | QueryParamConfigMapWithInherit,\n  arg2?: QueryParamConfig<any> | QueryParamOptions\n): UseQueryParamsResult<any> {\n  const { adapter, options: contextOptions } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n\n  // intepret the overloaded arguments\n  const { paramConfigMap: paramConfigMapWithInherit, options } = parseArguments(\n    arg1,\n    arg2\n  );\n\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n\n  // interpret params that were configured up the chain\n  let paramConfigMap = convertInheritedParamStringsToParams(\n    paramConfigMapWithInherit,\n    mergedOptions\n  );\n\n  // what is the current stringified value?\n  const parsedParams = memoSearchStringToObject(\n    mergedOptions.searchStringToObject,\n    adapter.location.search,\n    serializeUrlNameMap(paramConfigMap) // note we serialize for memo purposes\n  );\n\n  // do we want to include all params from the URL even if not configured?\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(\n      paramConfigMap,\n      Object.keys(parsedParams),\n      mergedOptions.params,\n      StringParam\n    );\n  }\n\n  // run decode on each key\n  const decodedValues = stableGetLatest(\n    parsedParams,\n    paramConfigMap,\n    decodedParamCache\n  );\n\n  // clear out unused values in cache\n  // use string for relatively stable effect dependency\n  const paramKeyString = Object.keys(paramConfigMap).join('\\0');\n  useEffect(() => {\n    const paramNames = paramKeyString.split('\\0');\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n\n  // create a setter for updating multiple query params at once\n  // use a ref for callback dependencies so we don't generate a new one unnecessarily\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions,\n  };\n  const callbackDependenciesRef =\n    useRef<typeof callbackDependencies>(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n\n  // create callback with stable identity\n  const [setQuery] = useState(() => {\n    const setQuery = (\n      changes: ChangesType<DecodedValueMap<any>>,\n      updateType?: UrlUpdateType\n    ) => {\n      // read from a ref so we don't generate new setters each time any change\n      const { adapter, paramConfigMap, options } =\n        callbackDependenciesRef.current!;\n      if (updateType == null) updateType = options.updateType;\n\n      enqueueUpdate(\n        {\n          changes,\n          updateType,\n          currentSearchString: adapter.location.search,\n          paramConfigMap,\n          options,\n          adapter,\n        },\n        { immediate: !options.enableBatching }\n      );\n    };\n\n    return setQuery;\n  });\n\n  return [decodedValues, setQuery];\n}\n\nexport default useQueryParams;\n\nfunction parseArguments(\n  arg1: string[] | QueryParamConfigMapWithInherit | undefined,\n  arg2: QueryParamConfig<any> | QueryParamOptions | undefined\n): {\n  paramConfigMap: QueryParamConfigMapWithInherit;\n  options: QueryParamOptions | undefined;\n} {\n  let paramConfigMap: QueryParamConfigMapWithInherit;\n  let options: QueryParamOptions | undefined;\n\n  if (arg1 === undefined) {\n    // useQueryParams()\n    paramConfigMap = {};\n    options = arg2 as QueryParamOptions | undefined;\n  } else if (Array.isArray(arg1)) {\n    // useQueryParams(['geo', 'other'])\n    // useQueryParams(['geo', 'other'], options)\n    paramConfigMap = Object.fromEntries(\n      arg1.map((key) => [key, 'inherit' as const])\n    );\n    options = arg2 as QueryParamOptions | undefined;\n  } else {\n    // useQueryParams({ geo: NumberParam })\n    // useQueryParams({ geo: NumberParam }, options)\n    paramConfigMap = arg1;\n    options = arg2 as QueryParamOptions | undefined;\n  }\n\n  return { paramConfigMap, options };\n}\n", "type EncodedValue = string | (string | null)[] | null | undefined;\n\ntype CachedParam = {\n  stringified: EncodedValue;\n  decoded: any;\n  decode: Function;\n};\n\n/**\n * simple cache that keeps values around so long as something\n * has registered interest in it (typically via calling useQueryParams).\n * Caches based on the stringified value as the key and the\n * last passed in decode function.\n */\nexport class DecodedParamCache {\n  private paramsMap: Map<string, CachedParam>;\n  private registeredParams: Map<string, number>;\n\n  constructor() {\n    this.paramsMap = new Map();\n    this.registeredParams = new Map();\n  }\n\n  set(\n    param: string,\n    stringifiedValue: EncodedValue,\n    decodedValue: any,\n    decode: Function\n  ) {\n    this.paramsMap.set(param, {\n      stringified: stringifiedValue,\n      decoded: decodedValue,\n      decode,\n    });\n  }\n\n  /**\n   * A param has been cached if the stringified value and decode function matches\n   */\n  has(param: string, stringifiedValue: EncodedValue, decode?: Function) {\n    if (!this.paramsMap.has(param)) return false;\n    const cachedParam = this.paramsMap.get(param);\n    if (!cachedParam) return false;\n\n    return (\n      cachedParam.stringified === stringifiedValue &&\n      (decode == null || cachedParam.decode === decode)\n    );\n  }\n\n  get(param: string) {\n    if (this.paramsMap.has(param)) return this.paramsMap.get(param)?.decoded;\n    return undefined;\n  }\n\n  /**\n   * Register interest in a set of param names. When these go to 0 they are cleaned out.\n   */\n  registerParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const currValue = this.registeredParams.get(param) || 0;\n      this.registeredParams.set(param, currValue + 1);\n    }\n  }\n\n  /**\n   * Unregister interest in a set of param names. If there is no remaining interest,\n   * remove the decoded value from the cache to prevent memory leaks.\n   */\n  unregisterParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const value = (this.registeredParams.get(param) || 0) - 1;\n      if (value <= 0) {\n        this.registeredParams.delete(param);\n        if (this.paramsMap.has(param)) {\n          this.paramsMap.delete(param);\n        }\n      } else {\n        this.registeredParams.set(param, value);\n      }\n    }\n  }\n\n  clear() {\n    this.paramsMap.clear();\n    this.registeredParams.clear();\n  }\n}\n\nexport const decodedParamCache = new DecodedParamCache();\n", "import {\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { QueryParamOptions } from './options';\nimport { QueryParamConfigMapWithInherit } from './types';\n\n/**\n * Convert inherit strings from a query param config to actual\n * parameters based on predefined ('inherited') mappings.\n * Defaults to StringParam.\n */\nexport function convertInheritedParamStringsToParams(\n  paramConfigMapWithInherit: QueryParamConfigMapWithInherit,\n  options: QueryParamOptions\n): QueryParamConfigMap {\n  const paramConfigMap: QueryParamConfigMap = {};\n  let hasInherit = false;\n\n  const hookKeys = Object.keys(paramConfigMapWithInherit);\n  let paramKeys = hookKeys;\n\n  // include known params if asked for explicitly, or no params were configured and we didn't\n  // explicitly say not to\n  const includeKnownParams =\n    options.includeKnownParams ||\n    (options.includeKnownParams !== false && hookKeys.length === 0);\n\n  if (includeKnownParams) {\n    const knownKeys = Object.keys(options.params ?? {});\n    paramKeys.push(...knownKeys);\n  }\n\n  for (const key of paramKeys) {\n    const param = paramConfigMapWithInherit[key];\n    // does it have an existing parameter definition? use it\n    if (param != null && typeof param === 'object') {\n      paramConfigMap[key] = param;\n      continue;\n    }\n\n    // otherwise, we have to inherit or use the default\n    hasInherit = true;\n\n    // default is StringParam\n    paramConfigMap[key] = options.params?.[key] ?? StringParam;\n  }\n\n  // if we didn't inherit anything, just return the input\n  if (!hasInherit) return paramConfigMapWithInherit as QueryParamConfigMap;\n\n  return paramConfigMap;\n}\n\n/**\n * Extends a config to include params for all specified keys,\n * defaulting to StringParam if not found in the inheritedParams\n * map.\n */\nexport function extendParamConfigForKeys(\n  baseParamConfigMap: QueryParamConfigMap,\n  paramKeys: string[],\n  inheritedParams?: QueryParamOptions['params'] | undefined,\n  defaultParam?: QueryParamConfig<any> | undefined\n) {\n  // if we aren't inheriting anything or there are no params, return the input\n  if (!inheritedParams || !paramKeys.length) return baseParamConfigMap;\n\n  let paramConfigMap = { ...baseParamConfigMap };\n  let hasInherit = false;\n  for (const paramKey of paramKeys) {\n    // if it is missing a parameter, fill it in\n    if (!Object.prototype.hasOwnProperty.call(paramConfigMap, paramKey)) {\n      paramConfigMap[paramKey] = inheritedParams[paramKey] ?? defaultParam;\n      hasInherit = true;\n    }\n  }\n\n  if (!hasInherit) return baseParamConfigMap;\n  return paramConfigMap;\n}\n", "/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license at\n * https://github.com/facebook/fbjs/blob/master/LICENSE\n */\n\n/*eslint-disable no-self-compare */\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x: any, y: any): boolean {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n\n * @pbeshai modification of shallowEqual to take into consideration a map providing\n * equals functions\n */\nexport default function shallowEqual(\n  objA: any,\n  objB: any,\n  equalMap?: any\n): boolean {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    const isEqual = equalMap?.[keysA[i]]?.equals ?? is;\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !isEqual(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {\n  DecodedValueMap,\n  EncodedQuery,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { DecodedParamCache } from './decodedParamCache';\nimport shallowEqual from './shallowEqual';\n\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nexport function getLatestDecodedValues<QPCMap extends QueryParamConfigMap>(\n  parsedParams: EncodedQuery,\n  paramConfigMap: QPCMap,\n  decodedParamCache: DecodedParamCache\n) {\n  const decodedValues: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // we have new encoded values, so let's get new decoded values.\n  // recompute new values but only for those that changed\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    // do we have a new encoded value?\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n\n    // if we have a new encoded value, re-decode. otherwise reuse cache\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n\n      // check if we had a cached value for this encoded value but a different encoder\n      // (sometimes people inline decode functions, e.g. withDefault...)\n      // AND we had a different equals check than ===\n      if (\n        paramConfig.equals &&\n        decodedParamCache.has(paramName, encodedValue)\n      ) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n\n      // do not cache undefined values\n      if (decodedValue !== undefined) {\n        decodedParamCache.set(\n          paramName,\n          encodedValue,\n          decodedValue,\n          paramConfig.decode\n        );\n      }\n    }\n\n    // in case the decode function didn't interpret `default` for some reason,\n    // we can interpret it here as a backup\n    if (decodedValue === undefined && paramConfig.default !== undefined) {\n      decodedValue = paramConfig.default;\n    }\n\n    decodedValues[paramName as keyof QPCMap] = decodedValue;\n  }\n\n  return decodedValues as DecodedValueMap<QPCMap>;\n}\n\n/**\n * Wrap get latest so we use the same exact object if the current\n * values are shallow equal to the previous.\n */\nexport function makeStableGetLatestDecodedValues() {\n  let prevDecodedValues: DecodedValueMap<any> | undefined;\n\n  function stableGetLatest<QPCMap extends QueryParamConfigMap>(\n    parsedParams: EncodedQuery,\n    paramConfigMap: QPCMap,\n    decodedParamCache: DecodedParamCache\n  ) {\n    const decodedValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n    if (\n      prevDecodedValues != null &&\n      shallowEqual(prevDecodedValues, decodedValues)\n    ) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n\n  return stableGetLatest;\n}\n", "import { EncodedValueMap, QueryParamConfigMap } from 'serialize-query-params';\n\n/**\n * Create an alias mapping using the optional `urlName` property on params\n */\nexport function serializeUrlNameMap(\n  paramConfigMap: QueryParamConfigMap\n): string | undefined {\n  let urlNameMapParts: string[] | undefined;\n  for (const paramName in paramConfigMap) {\n    if (paramConfigMap[paramName].urlName) {\n      const urlName = paramConfigMap[paramName].urlName;\n      const part = `${urlName}\\0${paramName}`;\n      if (!urlNameMapParts) urlNameMapParts = [part];\n      else urlNameMapParts.push(part);\n    }\n  }\n\n  return urlNameMapParts ? urlNameMapParts.join('\\n') : undefined;\n}\n\n/**\n * Converts the stringified alias/urlName map back into an object\n */\nexport function deserializeUrlNameMap(\n  urlNameMapStr: string | undefined\n): Record<string, string> | undefined {\n  if (!urlNameMapStr) return undefined;\n\n  return Object.fromEntries(\n    urlNameMapStr.split('\\n').map((part) => part.split('\\0'))\n  );\n}\n\n/**\n * converts { searchString: 'foo'} to { q: 'foo'} if the searchString\n * is configured to have \"q\" as its urlName.\n */\nexport function applyUrlNames(\n  encodedValues: Partial<EncodedValueMap<any>>,\n  paramConfigMap: QueryParamConfigMap\n) {\n  let newEncodedValues: Partial<EncodedValueMap<any>> = {};\n  for (const paramName in encodedValues) {\n    if (paramConfigMap[paramName]?.urlName != null) {\n      newEncodedValues[paramConfigMap[paramName].urlName!] =\n        encodedValues[paramName];\n    } else {\n      newEncodedValues[paramName] = encodedValues[paramName];\n    }\n  }\n\n  return newEncodedValues;\n}\n", "import { EncodedQuery } from 'serialize-query-params';\nimport shallowEqual from './shallowEqual';\nimport { deserializeUrlNameMap } from './urlName';\n\nlet cachedSearchString: string | undefined;\nlet cachedUrlNameMapString: string | undefined;\nlet cachedSearchStringToObjectFn:\n  | ((searchString: string) => EncodedQuery)\n  | undefined;\nlet cachedParsedQuery: EncodedQuery = {};\n\n/**\n * cached conversion of ?foo=1&bar=2 to { foo: '1', bar: '2' }\n */\nexport const memoSearchStringToObject = (\n  searchStringToObject: (searchString: string) => EncodedQuery,\n  searchString?: string | undefined,\n  /** optionally provide a mapping string to handle renames via `urlName`\n   * mapping are separated by \\n and mappings are urlName\\0paramName\n   */\n  urlNameMapStr?: string | undefined\n) => {\n  // if we have a cached version, just return it\n  if (\n    cachedSearchString === searchString &&\n    cachedSearchStringToObjectFn === searchStringToObject &&\n    cachedUrlNameMapString === urlNameMapStr\n  ) {\n    return cachedParsedQuery;\n  }\n\n  cachedSearchString = searchString;\n  cachedSearchStringToObjectFn = searchStringToObject;\n  const newParsedQuery = searchStringToObject(searchString ?? '');\n  cachedUrlNameMapString = urlNameMapStr;\n\n  const urlNameMap = deserializeUrlNameMap(urlNameMapStr);\n\n  // keep old values for keys if they are the same\n  for (let [key, value] of Object.entries(newParsedQuery)) {\n    // handle url name mapping\n    if (urlNameMap?.[key]) {\n      delete newParsedQuery[key];\n      key = urlNameMap[key];\n      newParsedQuery[key] = value;\n    }\n\n    const oldValue = cachedParsedQuery[key];\n    if (shallowEqual(value, oldValue)) {\n      newParsedQuery[key] = oldValue;\n    }\n  }\n\n  cachedParsedQuery = newParsedQuery;\n  return newParsedQuery;\n};\n", "import {\n  EncodedQuery,\n  QueryParamConfigMap,\n  searchStringToObject,\n  objectToSearchString,\n} from 'serialize-query-params';\nimport { UrlUpdateType } from './types';\n\nexport const defaultOptions: QueryParamOptionsWithRequired = {\n  searchStringToObject: searchStringToObject,\n  objectToSearchString: objectToSearchString,\n  updateType: 'pushIn',\n  includeKnownParams: undefined,\n  includeAllParams: false,\n  removeDefaultsFromUrl: false,\n  enableBatching: false,\n  skipUpdateWhenNoChange: true,\n};\n\nexport interface QueryParamOptions {\n  searchStringToObject?: (searchString: string) => EncodedQuery;\n  objectToSearchString?: (encodedParams: EncodedQuery) => string;\n  updateType?: UrlUpdateType;\n  includeKnownParams?: boolean;\n  includeAllParams?: boolean;\n  /** whether sets that result in no change to the location search string should be ignored (default: true) */\n  skipUpdateWhenNoChange?: boolean;\n  params?: QueryParamConfigMap;\n\n  /** when a value equals its default, do not encode it in the URL when updating */\n  removeDefaultsFromUrl?: boolean;\n\n  /**\n   * @experimental this is an experimental option to combine multiple `set` calls\n   * into a single URL update.\n   */\n  enableBatching?: boolean;\n}\n\ntype RequiredOptions = 'searchStringToObject' | 'objectToSearchString';\nexport type QueryParamOptionsWithRequired = Required<\n  Pick<QueryParamOptions, RequiredOptions>\n> &\n  Omit<QueryParamOptions, RequiredOptions>;\n\nexport function mergeOptions(\n  parentOptions: QueryParamOptionsWithRequired,\n  currOptions: QueryParamOptions | null | undefined\n): QueryParamOptionsWithRequired {\n  if (currOptions == null) {\n    currOptions = {};\n  }\n\n  const merged = { ...parentOptions, ...currOptions };\n\n  // deep merge param objects\n  if (currOptions.params && parentOptions.params) {\n    merged.params = { ...parentOptions.params, ...currOptions.params };\n  }\n\n  return merged;\n}\n", "import * as React from 'react';\nimport {\n  mergeOptions,\n  defaultOptions,\n  QueryParamOptions,\n  QueryParamOptionsWithRequired,\n} from './options';\nimport { QueryParamAdapter, QueryParamAdapterComponent } from './types';\n\n/**\n * Shape of the QueryParamContext, which the hooks consume to read and\n * update the URL state.\n */\ntype QueryParamContextValue = {\n  adapter: QueryParamAdapter;\n  options: QueryParamOptionsWithRequired;\n};\n\nconst providerlessContextValue: QueryParamContextValue = {\n  adapter: {} as QueryParamAdapter,\n  options: defaultOptions,\n};\n\nexport const QueryParamContext = React.createContext<QueryParamContextValue>(\n  providerlessContextValue\n);\n\nexport function useQueryParamContext() {\n  const value = React.useContext(QueryParamContext);\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    (value === undefined || value === providerlessContextValue)\n  ) {\n    throw new Error('useQueryParams must be used within a QueryParamProvider');\n  }\n\n  return value;\n}\n\n/**\n * Props for the Provider component, used to hook the active routing\n * system into our controls. Note only the root provider requires\n * `adapter`. We try to encourage that via intellisense by writing\n * the types this way (you must provide at least one of adapter or options,\n * default intellisense suggests adapter required.)\n */\ntype QueryParamProviderProps = {\n  /** Main app goes here */\n  children: React.ReactNode;\n} & (\n  | {\n      adapter?: never;\n      options: QueryParamOptions;\n    }\n  | {\n      /** required for the root provider but not for nested ones */\n      adapter: QueryParamAdapterComponent;\n      options?: QueryParamOptions;\n    }\n);\n\nfunction QueryParamProviderInner({\n  children,\n  adapter,\n  options,\n}: {\n  children: React.ReactNode;\n  adapter?: QueryParamAdapter | undefined;\n  options?: QueryParamOptions;\n}) {\n  // allow merging in parent options\n  const { adapter: parentAdapter, options: parentOptions } =\n    React.useContext(QueryParamContext);\n\n  const value = React.useMemo(() => {\n    return {\n      adapter: adapter ?? parentAdapter,\n      options: mergeOptions(\n        parentOptions,\n        options\n      ) as QueryParamOptionsWithRequired,\n    };\n  }, [adapter, options, parentAdapter, parentOptions]);\n\n  return (\n    <QueryParamContext.Provider value={value}>\n      {children}\n    </QueryParamContext.Provider>\n  );\n}\n\n/**\n * Context provider for query params to have access to the\n * active routing system, enabling updates to the URL.\n */\nexport function QueryParamProvider({\n  children,\n  adapter,\n  options,\n}: QueryParamProviderProps) {\n  const Adapter = adapter;\n  return Adapter ? (\n    <Adapter>\n      {(adapter) => (\n        <QueryParamProviderInner adapter={adapter} options={options}>\n          {children}\n        </QueryParamProviderInner>\n      )}\n    </Adapter>\n  ) : (\n    <QueryParamProviderInner options={options}>\n      {children}\n    </QueryParamProviderInner>\n  );\n}\n\nexport default QueryParamProvider;\n", "import {\n  DecodedValueMap,\n  encodeQueryParams,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport { extendParamConfigForKeys } from './inheritedParams';\nimport { getLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { QueryParamOptionsWithRequired } from './options';\nimport { removeDefaults } from './removeDefaults';\nimport { PartialLocation, QueryParamAdapter, UrlUpdateType } from './types';\nimport { applyUrlNames } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\n/**\n * Given a ?foo=1&bar=2 and { bar: 3, baz: true } produce ?foo=1&bar=3&baz=1\n * or similar, depending on updateType. The result will be prefixed with \"?\"\n * or just be the empty string.\n */\nexport function getUpdatedSearchString({\n  changes,\n  updateType,\n  currentSearchString,\n  paramConfigMap: baseParamConfigMap,\n  options,\n}: {\n  changes: ChangesType<DecodedValueMap<any>>;\n  updateType?: UrlUpdateType;\n  currentSearchString: string;\n  paramConfigMap: QueryParamConfigMap;\n  options: QueryParamOptionsWithRequired;\n}): string {\n  const { searchStringToObject, objectToSearchString } = options;\n  if (updateType == null) updateType = options.updateType;\n\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(\n    searchStringToObject,\n    currentSearchString\n  );\n\n  // see if we have unconfigured params in the changes that we can\n  // inherit to expand our config map instead of just using strings\n  const paramConfigMap = extendParamConfigForKeys(\n    baseParamConfigMap,\n    Object.keys(changes),\n    options.params\n  );\n\n  // update changes prior to encoding to handle removing defaults\n  // getting latest values when functional update\n  let changesToUse: Partial<DecodedValueMap<any>>;\n\n  // functional updates here get the latest values\n  if (typeof changes === 'function') {\n    const latestValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n\n    changesToUse = (changes as Function)(latestValues);\n  } else {\n    // simple update here\n    changesToUse = changes;\n  }\n\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n\n  // remove defaults\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n\n  // interpret urlNames\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n\n  let newSearchString: string;\n  if (updateType === 'push' || updateType === 'replace') {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges,\n    });\n  }\n\n  if (newSearchString?.length && newSearchString[0] !== '?') {\n    (newSearchString as any) = `?${newSearchString}`;\n  }\n\n  return newSearchString ?? '';\n}\n\n/**\n * uses an adapter to update a location object and optionally\n * navigate based on the updateType\n */\nexport function updateSearchString({\n  searchString,\n  adapter,\n  navigate,\n  updateType,\n}: {\n  searchString: string;\n  adapter: QueryParamAdapter;\n  navigate: boolean;\n  updateType?: UrlUpdateType;\n}) {\n  const currentLocation = adapter.location;\n\n  // update the location and URL\n  const newLocation: PartialLocation = {\n    ...currentLocation,\n    search: searchString,\n  };\n\n  if (navigate) {\n    // be defensive about checking updateType since it is somewhat easy to\n    // accidentally pass a second argument to the setter.\n    if (typeof updateType === 'string' && updateType.startsWith('replace')) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\n\ntype UpdateArgs = Parameters<typeof getUpdatedSearchString>[0] & {\n  adapter: QueryParamAdapter;\n};\n\nconst immediateTask = (task: Function) => task();\nconst timeoutTask = (task: Function) => setTimeout(() => task(), 0);\n// alternative could be native `queueMicrotask`\n\nconst updateQueue: UpdateArgs[] = [];\n\n/**\n * support batching by enqueuing updates (if immediate is not true)\n */\nexport function enqueueUpdate(\n  args: UpdateArgs,\n  { immediate }: { immediate?: boolean } = {}\n) {\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n\n      let searchString: string | undefined;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate: UpdateArgs =\n          i === 0\n            ? updates[i]\n            : { ...updates[i], currentSearchString: searchString! };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n\n      // do not update unnecessarily #234\n      if (\n        args.options.skipUpdateWhenNoChange &&\n        searchString === initialSearchString\n      ) {\n        return;\n      }\n\n      updateSearchString({\n        searchString: searchString ?? '',\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType,\n      });\n    });\n  }\n}\n", "import { EncodedValueMap, QueryParamConfigMap } from 'serialize-query-params';\n\n/**\n * Note: This function is destructive - it mutates encodedValues.\n * Remove values that match the encoded defaults from the encodedValues object\n */\nexport function removeDefaults(\n  encodedValues: Partial<EncodedValueMap<any>>,\n  paramConfigMap: QueryParamConfigMap\n) {\n  for (const paramName in encodedValues) {\n    // does it have a configured default and does it have a non-undefined value?\n    if (\n      paramConfigMap[paramName]?.default !== undefined &&\n      encodedValues[paramName] !== undefined\n    ) {\n      // does its current value match the encoded default\n      const encodedDefault = paramConfigMap[paramName].encode(\n        paramConfigMap[paramName].default\n      );\n      if (encodedDefault === encodedValues[paramName]) {\n        encodedValues[paramName] = undefined;\n      }\n    }\n  }\n}\n", "import * as React from 'react';\nimport { QueryParamConfigMap, DecodedValueMap } from 'serialize-query-params';\nimport useQueryParams from './useQueryParams';\nimport { SetQuery } from './types';\n\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\ntype Diff<T, K> = Omit<T, keyof K>;\n\nexport interface InjectedQueryProps<QPCMap extends QueryParamConfigMap> {\n  query: DecodedValueMap<QPCMap>;\n  setQuery: SetQuery<QPCMap>;\n}\n\n/**\n * HOC to provide query parameters via props `query` and `setQuery`\n * NOTE: I couldn't get type to automatically infer generic when\n * using the format withQueryParams(config)(component), so I switched\n * to withQueryParams(config, component).\n * See: https://github.com/microsoft/TypeScript/issues/30134\n */\nexport function withQueryParams<\n  QPCMap extends QueryParamConfigMap,\n  P extends InjectedQueryProps<QPCMap>\n>(paramConfigMap: QPCMap, WrappedComponent: React.ComponentType<P>) {\n  // return a FC that takes props excluding query and setQuery\n  const Component: React.FC<Diff<P, InjectedQueryProps<QPCMap>>> = (props) => {\n    const [query, setQuery] = useQueryParams(paramConfigMap);\n\n    // see https://github.com/microsoft/TypeScript/issues/28938#issuecomment-450636046 for why `...props as P`\n    return (\n      <WrappedComponent query={query} setQuery={setQuery} {...(props as any)} />\n    );\n  };\n  Component.displayName = `withQueryParams(${\n    WrappedComponent.displayName || WrappedComponent.name || 'Component'\n  })`;\n\n  return Component;\n}\n\nexport default withQueryParams;\n\n/**\n * HOC to provide query parameters via props mapToProps (similar to\n * react-redux connect style mapStateToProps)\n * NOTE: I couldn't get type to automatically infer generic when\n * using the format withQueryParams(config)(component), so I switched\n * to withQueryParams(config, component).\n * See: https://github.com/microsoft/TypeScript/issues/30134\n */\nexport function withQueryParamsMapped<\n  QPCMap extends QueryParamConfigMap,\n  MappedProps extends object,\n  P extends MappedProps\n>(\n  paramConfigMap: QPCMap,\n  mapToProps: (\n    query: DecodedValueMap<QPCMap>,\n    setQuery: SetQuery<QPCMap>,\n    props: Diff<P, MappedProps>\n  ) => MappedProps,\n  WrappedComponent: React.ComponentType<P>\n) {\n  // return a FC that takes props excluding query and setQuery\n  const Component: React.FC<Diff<P, MappedProps>> = (props) => {\n    const [query, setQuery] = useQueryParams(paramConfigMap);\n    const propsToAdd = mapToProps(query, setQuery, props);\n\n    // see https://github.com/microsoft/TypeScript/issues/28938#issuecomment-450636046 for why `...props as P`\n    return <WrappedComponent {...propsToAdd} {...(props as P)} />;\n  };\n  Component.displayName = `withQueryParams(${\n    WrappedComponent.displayName || WrappedComponent.name || 'Component'\n  })`;\n\n  return Component;\n}\n", "import { QueryParamConfigMap, DecodedValueMap } from 'serialize-query-params';\nimport useQueryParams from './useQueryParams';\nimport { SetQuery } from './types';\n\nexport interface QueryRenderProps<QPCMap extends QueryParamConfigMap> {\n  query: DecodedValueMap<QPCMap>;\n  setQuery: SetQuery<QPCMap>;\n}\n\nexport interface QueryParamsProps<QPCMap extends QueryParamConfigMap> {\n  config: QPCMap;\n  children: (renderProps: QueryRenderProps<QPCMap>) => JSX.Element;\n}\n\nexport const QueryParams = <QPCMap extends QueryParamConfigMap>({\n  config,\n  children,\n}: QueryParamsProps<QPCMap>) => {\n  const [query, setQuery] = useQueryParams(config);\n  return children({ query, setQuery });\n};\n\nexport default QueryParams;\n"],
  "mappings": "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",
  "names": ["import_react", "import_serialize_query_params", "decodedParamCache", "searchStringToObject", "import_serialize_query_params", "adapter", "import_serialize_query_params", "searchStringToObject", "objectToSearchString", "setQuery", "adapter", "paramConfigMap", "options", "React"]
}
