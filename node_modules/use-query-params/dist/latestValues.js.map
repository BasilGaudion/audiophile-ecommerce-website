{
  "version": 3,
  "sources": ["../src/latestValues.ts"],
  "sourcesContent": ["import {\n  DecodedValueMap,\n  EncodedQuery,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { DecodedParamCache } from './decodedParamCache';\nimport shallowEqual from './shallowEqual';\n\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nexport function getLatestDecodedValues<QPCMap extends QueryParamConfigMap>(\n  parsedParams: EncodedQuery,\n  paramConfigMap: QPCMap,\n  decodedParamCache: DecodedParamCache\n) {\n  const decodedValues: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // we have new encoded values, so let's get new decoded values.\n  // recompute new values but only for those that changed\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    // do we have a new encoded value?\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n\n    // if we have a new encoded value, re-decode. otherwise reuse cache\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n\n      // check if we had a cached value for this encoded value but a different encoder\n      // (sometimes people inline decode functions, e.g. withDefault...)\n      // AND we had a different equals check than ===\n      if (\n        paramConfig.equals &&\n        decodedParamCache.has(paramName, encodedValue)\n      ) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n\n      // do not cache undefined values\n      if (decodedValue !== undefined) {\n        decodedParamCache.set(\n          paramName,\n          encodedValue,\n          decodedValue,\n          paramConfig.decode\n        );\n      }\n    }\n\n    // in case the decode function didn't interpret `default` for some reason,\n    // we can interpret it here as a backup\n    if (decodedValue === undefined && paramConfig.default !== undefined) {\n      decodedValue = paramConfig.default;\n    }\n\n    decodedValues[paramName as keyof QPCMap] = decodedValue;\n  }\n\n  return decodedValues as DecodedValueMap<QPCMap>;\n}\n\n/**\n * Wrap get latest so we use the same exact object if the current\n * values are shallow equal to the previous.\n */\nexport function makeStableGetLatestDecodedValues() {\n  let prevDecodedValues: DecodedValueMap<any> | undefined;\n\n  function stableGetLatest<QPCMap extends QueryParamConfigMap>(\n    parsedParams: EncodedQuery,\n    paramConfigMap: QPCMap,\n    decodedParamCache: DecodedParamCache\n  ) {\n    const decodedValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n    if (\n      prevDecodedValues != null &&\n      shallowEqual(prevDecodedValues, decodedValues)\n    ) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n\n  return stableGetLatest;\n}\n"],
  "mappings": "AAMA,OAAO,kBAAkB;AAMlB,SAAS,uBACd,cACA,gBACA,mBACA;AACA,QAAM,gBAAkD,CAAC;AAIzD,QAAM,aAAa,OAAO,KAAK,cAAc;AAC7C,aAAW,aAAa,YAAY;AAElC,UAAM,cAAc,eAAe;AACnC,UAAM,eAAe,aAAa;AAGlC,QAAI;AACJ,QAAI,kBAAkB,IAAI,WAAW,cAAc,YAAY,MAAM,GAAG;AACtE,qBAAe,kBAAkB,IAAI,SAAS;AAAA,IAChD,OAAO;AACL,qBAAe,YAAY,OAAO,YAAY;AAK9C,UACE,YAAY,UACZ,kBAAkB,IAAI,WAAW,YAAY,GAC7C;AACA,cAAM,kBAAkB,kBAAkB,IAAI,SAAS;AACvD,YAAI,YAAY,OAAO,cAAc,eAAe,GAAG;AACrD,yBAAe;AAAA,QACjB;AAAA,MACF;AAGA,UAAI,iBAAiB,QAAW;AAC9B,0BAAkB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,UACA,YAAY;AAAA,QACd;AAAA,MACF;AAAA,IACF;AAIA,QAAI,iBAAiB,UAAa,YAAY,YAAY,QAAW;AACnE,qBAAe,YAAY;AAAA,IAC7B;AAEA,kBAAc,aAA6B;AAAA,EAC7C;AAEA,SAAO;AACT;AAMO,SAAS,mCAAmC;AACjD,MAAI;AAEJ,WAAS,gBACP,cACA,gBACA,mBACA;AACA,UAAM,gBAAgB;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,QACE,qBAAqB,QACrB,aAAa,mBAAmB,aAAa,GAC7C;AACA,aAAO;AAAA,IACT;AACA,wBAAoB;AACpB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;",
  "names": []
}
