{
  "version": 3,
  "sources": ["../src/useQueryParams.ts"],
  "sourcesContent": ["import { useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  DecodedValueMap,\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport {\n  extendParamConfigForKeys,\n  convertInheritedParamStringsToParams,\n} from './inheritedParams';\nimport { makeStableGetLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { mergeOptions, QueryParamOptions } from './options';\nimport { useQueryParamContext } from './QueryParamProvider';\nimport {\n  QueryParamConfigMapWithInherit,\n  SetQuery,\n  UrlUpdateType,\n} from './types';\nimport { enqueueUpdate } from './updateSearchString';\nimport { serializeUrlNameMap } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\ntype UseQueryParamsResult<QPCMap extends QueryParamConfigMap> = [\n  DecodedValueMap<QPCMap>,\n  SetQuery<QPCMap>\n];\ntype ExpandInherits<QPCMap extends QueryParamConfigMapWithInherit> = {\n  [ParamName in keyof QPCMap]: QPCMap[ParamName] extends string\n    ? typeof StringParam\n    : QPCMap[ParamName] extends QueryParamConfig<any>\n    ? QPCMap[ParamName]\n    : never;\n};\n\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMap = QueryParamConfigMap\n>(): UseQueryParamsResult<QPCMap>;\nexport function useQueryParams<QPCMap extends QueryParamConfigMapWithInherit>(\n  names: string[],\n  options?: QueryParamOptions\n): UseQueryParamsResult<ExpandInherits<QPCMap>>;\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMapWithInherit,\n  OutputQPCMap extends QueryParamConfigMap = ExpandInherits<QPCMap>\n>(\n  paramConfigMap: QPCMap,\n  options?: QueryParamOptions\n): UseQueryParamsResult<OutputQPCMap>;\nexport function useQueryParams(\n  arg1?: string[] | QueryParamConfigMapWithInherit,\n  arg2?: QueryParamConfig<any> | QueryParamOptions\n): UseQueryParamsResult<any> {\n  const { adapter, options: contextOptions } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n\n  // intepret the overloaded arguments\n  const { paramConfigMap: paramConfigMapWithInherit, options } = parseArguments(\n    arg1,\n    arg2\n  );\n\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n\n  // interpret params that were configured up the chain\n  let paramConfigMap = convertInheritedParamStringsToParams(\n    paramConfigMapWithInherit,\n    mergedOptions\n  );\n\n  // what is the current stringified value?\n  const parsedParams = memoSearchStringToObject(\n    mergedOptions.searchStringToObject,\n    adapter.location.search,\n    serializeUrlNameMap(paramConfigMap) // note we serialize for memo purposes\n  );\n\n  // do we want to include all params from the URL even if not configured?\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(\n      paramConfigMap,\n      Object.keys(parsedParams),\n      mergedOptions.params,\n      StringParam\n    );\n  }\n\n  // run decode on each key\n  const decodedValues = stableGetLatest(\n    parsedParams,\n    paramConfigMap,\n    decodedParamCache\n  );\n\n  // clear out unused values in cache\n  // use string for relatively stable effect dependency\n  const paramKeyString = Object.keys(paramConfigMap).join('\\0');\n  useEffect(() => {\n    const paramNames = paramKeyString.split('\\0');\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n\n  // create a setter for updating multiple query params at once\n  // use a ref for callback dependencies so we don't generate a new one unnecessarily\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions,\n  };\n  const callbackDependenciesRef =\n    useRef<typeof callbackDependencies>(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n\n  // create callback with stable identity\n  const [setQuery] = useState(() => {\n    const setQuery = (\n      changes: ChangesType<DecodedValueMap<any>>,\n      updateType?: UrlUpdateType\n    ) => {\n      // read from a ref so we don't generate new setters each time any change\n      const { adapter, paramConfigMap, options } =\n        callbackDependenciesRef.current!;\n      if (updateType == null) updateType = options.updateType;\n\n      enqueueUpdate(\n        {\n          changes,\n          updateType,\n          currentSearchString: adapter.location.search,\n          paramConfigMap,\n          options,\n          adapter,\n        },\n        { immediate: !options.enableBatching }\n      );\n    };\n\n    return setQuery;\n  });\n\n  return [decodedValues, setQuery];\n}\n\nexport default useQueryParams;\n\nfunction parseArguments(\n  arg1: string[] | QueryParamConfigMapWithInherit | undefined,\n  arg2: QueryParamConfig<any> | QueryParamOptions | undefined\n): {\n  paramConfigMap: QueryParamConfigMapWithInherit;\n  options: QueryParamOptions | undefined;\n} {\n  let paramConfigMap: QueryParamConfigMapWithInherit;\n  let options: QueryParamOptions | undefined;\n\n  if (arg1 === undefined) {\n    // useQueryParams()\n    paramConfigMap = {};\n    options = arg2 as QueryParamOptions | undefined;\n  } else if (Array.isArray(arg1)) {\n    // useQueryParams(['geo', 'other'])\n    // useQueryParams(['geo', 'other'], options)\n    paramConfigMap = Object.fromEntries(\n      arg1.map((key) => [key, 'inherit' as const])\n    );\n    options = arg2 as QueryParamOptions | undefined;\n  } else {\n    // useQueryParams({ geo: NumberParam })\n    // useQueryParams({ geo: NumberParam }, options)\n    paramConfigMap = arg1;\n    options = arg2 as QueryParamOptions | undefined;\n  }\n\n  return { paramConfigMap, options };\n}\n"],
  "mappings": "AAAA,SAAS,WAAW,SAAS,QAAQ,gBAAgB;AACrD;AAAA,EAIE;AAAA,OACK;AACP,SAAS,yBAAyB;AAClC;AAAA,EACE;AAAA,EACA;AAAA,OACK;AACP,SAAS,wCAAwC;AACjD,SAAS,gCAAgC;AACzC,SAAS,oBAAuC;AAChD,SAAS,4BAA4B;AAMrC,SAAS,qBAAqB;AAC9B,SAAS,2BAA2B;AAqC7B,SAAS,eACd,MACA,MAC2B;AAC3B,QAAM,EAAE,SAAS,SAAS,eAAe,IAAI,qBAAqB;AAClE,QAAM,CAAC,eAAe,IAAI,SAAS,gCAAgC;AAGnE,QAAM,EAAE,gBAAgB,2BAA2B,QAAQ,IAAI;AAAA,IAC7D;AAAA,IACA;AAAA,EACF;AAEA,QAAM,gBAAgB,QAAQ,MAAM;AAClC,WAAO,aAAa,gBAAgB,OAAO;AAAA,EAC7C,GAAG,CAAC,gBAAgB,OAAO,CAAC;AAG5B,MAAI,iBAAiB;AAAA,IACnB;AAAA,IACA;AAAA,EACF;AAGA,QAAM,eAAe;AAAA,IACnB,cAAc;AAAA,IACd,QAAQ,SAAS;AAAA,IACjB,oBAAoB,cAAc;AAAA,EACpC;AAGA,MAAI,cAAc,kBAAkB;AAClC,qBAAiB;AAAA,MACf;AAAA,MACA,OAAO,KAAK,YAAY;AAAA,MACxB,cAAc;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAGA,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAIA,QAAM,iBAAiB,OAAO,KAAK,cAAc,EAAE,KAAK,IAAI;AAC5D,YAAU,MAAM;AACd,UAAM,aAAa,eAAe,MAAM,IAAI;AAC5C,sBAAkB,eAAe,UAAU;AAC3C,WAAO,MAAM;AACX,wBAAkB,iBAAiB,UAAU;AAAA,IAC/C;AAAA,EACF,GAAG,CAAC,cAAc,CAAC;AAInB,QAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,SAAS;AAAA,EACX;AACA,QAAM,0BACJ,OAAoC,oBAAoB;AAC1D,MAAI,wBAAwB,WAAW,MAAM;AAC3C,4BAAwB,UAAU;AAAA,EACpC;AACA,YAAU,MAAM;AACd,4BAAwB,QAAQ,UAAU;AAC1C,4BAAwB,QAAQ,iBAAiB;AACjD,4BAAwB,QAAQ,UAAU;AAAA,EAC5C,GAAG,CAAC,SAAS,gBAAgB,aAAa,CAAC;AAG3C,QAAM,CAAC,QAAQ,IAAI,SAAS,MAAM;AAChC,UAAMA,YAAW,CACf,SACA,eACG;AAEH,YAAM,EAAE,SAAAC,UAAS,gBAAAC,iBAAgB,SAAAC,SAAQ,IACvC,wBAAwB;AAC1B,UAAI,cAAc;AAAM,qBAAaA,SAAQ;AAE7C;AAAA,QACE;AAAA,UACE;AAAA,UACA;AAAA,UACA,qBAAqBF,SAAQ,SAAS;AAAA,UACtC,gBAAAC;AAAA,UACA,SAAAC;AAAA,UACA,SAAAF;AAAA,QACF;AAAA,QACA,EAAE,WAAW,CAACE,SAAQ,eAAe;AAAA,MACvC;AAAA,IACF;AAEA,WAAOH;AAAA,EACT,CAAC;AAED,SAAO,CAAC,eAAe,QAAQ;AACjC;AAEA,IAAO,yBAAQ;AAEf,SAAS,eACP,MACA,MAIA;AACA,MAAI;AACJ,MAAI;AAEJ,MAAI,SAAS,QAAW;AAEtB,qBAAiB,CAAC;AAClB,cAAU;AAAA,EACZ,WAAW,MAAM,QAAQ,IAAI,GAAG;AAG9B,qBAAiB,OAAO;AAAA,MACtB,KAAK,IAAI,CAAC,QAAQ,CAAC,KAAK,SAAkB,CAAC;AAAA,IAC7C;AACA,cAAU;AAAA,EACZ,OAAO;AAGL,qBAAiB;AACjB,cAAU;AAAA,EACZ;AAEA,SAAO,EAAE,gBAAgB,QAAQ;AACnC;",
  "names": ["setQuery", "adapter", "paramConfigMap", "options"]
}
