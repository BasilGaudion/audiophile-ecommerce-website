{
  "version": 3,
  "sources": ["../src/decodedParamCache.ts"],
  "sourcesContent": ["type EncodedValue = string | (string | null)[] | null | undefined;\n\ntype CachedParam = {\n  stringified: EncodedValue;\n  decoded: any;\n  decode: Function;\n};\n\n/**\n * simple cache that keeps values around so long as something\n * has registered interest in it (typically via calling useQueryParams).\n * Caches based on the stringified value as the key and the\n * last passed in decode function.\n */\nexport class DecodedParamCache {\n  private paramsMap: Map<string, CachedParam>;\n  private registeredParams: Map<string, number>;\n\n  constructor() {\n    this.paramsMap = new Map();\n    this.registeredParams = new Map();\n  }\n\n  set(\n    param: string,\n    stringifiedValue: EncodedValue,\n    decodedValue: any,\n    decode: Function\n  ) {\n    this.paramsMap.set(param, {\n      stringified: stringifiedValue,\n      decoded: decodedValue,\n      decode,\n    });\n  }\n\n  /**\n   * A param has been cached if the stringified value and decode function matches\n   */\n  has(param: string, stringifiedValue: EncodedValue, decode?: Function) {\n    if (!this.paramsMap.has(param)) return false;\n    const cachedParam = this.paramsMap.get(param);\n    if (!cachedParam) return false;\n\n    return (\n      cachedParam.stringified === stringifiedValue &&\n      (decode == null || cachedParam.decode === decode)\n    );\n  }\n\n  get(param: string) {\n    if (this.paramsMap.has(param)) return this.paramsMap.get(param)?.decoded;\n    return undefined;\n  }\n\n  /**\n   * Register interest in a set of param names. When these go to 0 they are cleaned out.\n   */\n  registerParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const currValue = this.registeredParams.get(param) || 0;\n      this.registeredParams.set(param, currValue + 1);\n    }\n  }\n\n  /**\n   * Unregister interest in a set of param names. If there is no remaining interest,\n   * remove the decoded value from the cache to prevent memory leaks.\n   */\n  unregisterParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const value = (this.registeredParams.get(param) || 0) - 1;\n      if (value <= 0) {\n        this.registeredParams.delete(param);\n        if (this.paramsMap.has(param)) {\n          this.paramsMap.delete(param);\n        }\n      } else {\n        this.registeredParams.set(param, value);\n      }\n    }\n  }\n\n  clear() {\n    this.paramsMap.clear();\n    this.registeredParams.clear();\n  }\n}\n\nexport const decodedParamCache = new DecodedParamCache();\n"],
  "mappings": "AAcO,MAAM,kBAAkB;AAAA,EAI7B,cAAc;AACZ,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,mBAAmB,oBAAI,IAAI;AAAA,EAClC;AAAA,EAEA,IACE,OACA,kBACA,cACA,QACA;AACA,SAAK,UAAU,IAAI,OAAO;AAAA,MACxB,aAAa;AAAA,MACb,SAAS;AAAA,MACT;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAKA,IAAI,OAAe,kBAAgC,QAAmB;AACpE,QAAI,CAAC,KAAK,UAAU,IAAI,KAAK;AAAG,aAAO;AACvC,UAAM,cAAc,KAAK,UAAU,IAAI,KAAK;AAC5C,QAAI,CAAC;AAAa,aAAO;AAEzB,WACE,YAAY,gBAAgB,qBAC3B,UAAU,QAAQ,YAAY,WAAW;AAAA,EAE9C;AAAA,EAEA,IAAI,OAAe;AAlDrB;AAmDI,QAAI,KAAK,UAAU,IAAI,KAAK;AAAG,cAAO,UAAK,UAAU,IAAI,KAAK,MAAxB,mBAA2B;AACjE,WAAO;AAAA,EACT;AAAA,EAKA,eAAe,YAAsB;AACnC,eAAW,SAAS,YAAY;AAC9B,YAAM,YAAY,KAAK,iBAAiB,IAAI,KAAK,KAAK;AACtD,WAAK,iBAAiB,IAAI,OAAO,YAAY,CAAC;AAAA,IAChD;AAAA,EACF;AAAA,EAMA,iBAAiB,YAAsB;AACrC,eAAW,SAAS,YAAY;AAC9B,YAAM,SAAS,KAAK,iBAAiB,IAAI,KAAK,KAAK,KAAK;AACxD,UAAI,SAAS,GAAG;AACd,aAAK,iBAAiB,OAAO,KAAK;AAClC,YAAI,KAAK,UAAU,IAAI,KAAK,GAAG;AAC7B,eAAK,UAAU,OAAO,KAAK;AAAA,QAC7B;AAAA,MACF,OAAO;AACL,aAAK,iBAAiB,IAAI,OAAO,KAAK;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAAA,EAEA,QAAQ;AACN,SAAK,UAAU,MAAM;AACrB,SAAK,iBAAiB,MAAM;AAAA,EAC9B;AACF;AAEO,MAAM,oBAAoB,IAAI,kBAAkB;",
  "names": []
}
